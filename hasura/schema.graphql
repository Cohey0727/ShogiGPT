schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""最善手コンテンツ"""
type BestMoveContent {
  depth: Int
  evaluation: Float
  move: String!
  type: String!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""チャットメッセージ"""
type ChatMessage {
  """メッセージコンテンツ（Markdownや候補手などを含む配列）"""
  contents: [MessageContent!]!

  """作成日時"""
  createdAt: String!

  """メッセージID"""
  id: String!

  """入力途中かどうか（AI応答待ち）"""
  isPartial: Boolean!

  """対局ID"""
  matchId: String!

  """メッセージ役割"""
  role: String!
}

"""
columns and relationships of "chat_messages"
"""
type ChatMessages {
  contents(
    """JSON select path"""
    path: String
  ): jsonb!
  createdAt: timestamp!
  id: String!
  isPartial: Boolean!

  """An object relationship"""
  match: Matches!
  matchId: String!
  metadata: String
  role: MessageRole!
}

"""
order by aggregate values of table "chat_messages"
"""
input ChatMessagesAggregateOrderBy {
  count: OrderBy
  max: ChatMessagesMaxOrderBy
  min: ChatMessagesMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ChatMessagesAppendInput {
  contents: jsonb
}

"""
input type for inserting array relation for remote table "chat_messages"
"""
input ChatMessagesArrRelInsertInput {
  data: [ChatMessagesInsertInput!]!

  """upsert condition"""
  onConflict: ChatMessagesOnConflict
}

"""
Boolean expression to filter rows from the table "chat_messages". All fields are combined with a logical 'AND'.
"""
input ChatMessagesBoolExp {
  _and: [ChatMessagesBoolExp!]
  _not: ChatMessagesBoolExp
  _or: [ChatMessagesBoolExp!]
  contents: JsonbComparisonExp
  createdAt: TimestampComparisonExp
  id: StringComparisonExp
  isPartial: BooleanComparisonExp
  match: MatchesBoolExp
  matchId: StringComparisonExp
  metadata: StringComparisonExp
  role: MessageRoleComparisonExp
}

"""
unique or primary key constraints on table "chat_messages"
"""
enum ChatMessagesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_messages_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ChatMessagesDeleteAtPathInput {
  contents: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input ChatMessagesDeleteElemInput {
  contents: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ChatMessagesDeleteKeyInput {
  contents: String
}

"""
input type for inserting data into table "chat_messages"
"""
input ChatMessagesInsertInput {
  contents: jsonb
  createdAt: timestamp
  id: String
  isPartial: Boolean
  match: MatchesObjRelInsertInput
  matchId: String
  metadata: String
  role: MessageRole
}

"""
order by max() on columns of table "chat_messages"
"""
input ChatMessagesMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  matchId: OrderBy
  metadata: OrderBy
  role: OrderBy
}

"""
order by min() on columns of table "chat_messages"
"""
input ChatMessagesMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  matchId: OrderBy
  metadata: OrderBy
  role: OrderBy
}

"""
response of any mutation on the table "chat_messages"
"""
type ChatMessagesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ChatMessages!]!
}

"""
on_conflict condition type for table "chat_messages"
"""
input ChatMessagesOnConflict {
  constraint: ChatMessagesConstraint!
  updateColumns: [ChatMessagesUpdateColumn!]! = []
  where: ChatMessagesBoolExp
}

"""Ordering options when selecting data from "chat_messages"."""
input ChatMessagesOrderBy {
  contents: OrderBy
  createdAt: OrderBy
  id: OrderBy
  isPartial: OrderBy
  match: MatchesOrderBy
  matchId: OrderBy
  metadata: OrderBy
  role: OrderBy
}

"""primary key columns input for table: chat_messages"""
input ChatMessagesPkColumnsInput {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ChatMessagesPrependInput {
  contents: jsonb
}

"""
select columns of table "chat_messages"
"""
enum ChatMessagesSelectColumn {
  """column name"""
  contents

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPartial

  """column name"""
  matchId

  """column name"""
  metadata

  """column name"""
  role
}

"""
input type for updating data in table "chat_messages"
"""
input ChatMessagesSetInput {
  contents: jsonb
  createdAt: timestamp
  id: String
  isPartial: Boolean
  matchId: String
  metadata: String
  role: MessageRole
}

"""
Streaming cursor of the table "chat_messages"
"""
input ChatMessagesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatMessagesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatMessagesStreamCursorValueInput {
  contents: jsonb
  createdAt: timestamp
  id: String
  isPartial: Boolean
  matchId: String
  metadata: String
  role: MessageRole
}

"""
update columns of table "chat_messages"
"""
enum ChatMessagesUpdateColumn {
  """column name"""
  contents

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPartial

  """column name"""
  matchId

  """column name"""
  metadata

  """column name"""
  role
}

input ChatMessagesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ChatMessagesAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ChatMessagesDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _deleteElem: ChatMessagesDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ChatMessagesDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ChatMessagesPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatMessagesSetInput

  """filter the rows which have to be updated"""
  where: ChatMessagesBoolExp!
}

"""対局作成リクエスト"""
input CreateMatchInput {
  """後手のプレイヤータイプ"""
  goteType: PlayerType

  """対局ID（指定しない場合は自動生成）"""
  id: String

  """後手のプレイヤー名"""
  playerGote: String

  """先手のプレイヤー名"""
  playerSente: String

  """先手のプレイヤータイプ"""
  senteType: PlayerType
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""対局状態評価リクエスト"""
input EvaluateMatchStateInput {
  """局面番号"""
  index: Int!

  """対局ID"""
  matchId: String!

  """候補手の数（MultiPV、デフォルト: 3）"""
  multipv: Int

  """消費時間（秒）"""
  thinkingTime: Int
}

"""対局状態評価結果"""
type EvaluateMatchStateResult {
  """評価対象のMatchStateのID"""
  matchStateId: String!

  """成功したかどうか"""
  success: Boolean!

  """思考中を示すチャットメッセージ"""
  thinkingMessage: ChatMessage!
}

type Health {
  status: String!
  timestamp: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""Markdownコンテンツ"""
type MarkdownContent {
  content: String!
  type: String!
}

"""対局情報"""
type Match {
  """作成日時"""
  createdAt: String!

  """後手のプレイヤータイプ"""
  goteType: PlayerType!

  """対局ID"""
  id: String!

  """後手のプレイヤー名"""
  playerGote: String

  """先手のプレイヤー名"""
  playerSente: String

  """先手のプレイヤータイプ"""
  senteType: PlayerType!

  """対局状況"""
  status: String!

  """更新日時"""
  updatedAt: String!
}

"""
columns and relationships of "matches"
"""
type Matches {
  """An array relationship"""
  chatMessages(
    """distinct select on columns"""
    distinctOn: [ChatMessagesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatMessagesOrderBy!]

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!
  createdAt: timestamp!
  goteType: PlayerType!
  id: String!

  """An array relationship"""
  matchStates(
    """distinct select on columns"""
    distinctOn: [MatchStatesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchStatesOrderBy!]

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!
  playerGote: String
  playerSente: String
  senteType: PlayerType!
  status: MatchStatus!
  updatedAt: timestamp!
}

"""
Boolean expression to filter rows from the table "matches". All fields are combined with a logical 'AND'.
"""
input MatchesBoolExp {
  _and: [MatchesBoolExp!]
  _not: MatchesBoolExp
  _or: [MatchesBoolExp!]
  chatMessages: ChatMessagesBoolExp
  createdAt: TimestampComparisonExp
  goteType: PlayerTypeComparisonExp
  id: StringComparisonExp
  matchStates: MatchStatesBoolExp
  playerGote: StringComparisonExp
  playerSente: StringComparisonExp
  senteType: PlayerTypeComparisonExp
  status: MatchStatusComparisonExp
  updatedAt: TimestampComparisonExp
}

"""
unique or primary key constraints on table "matches"
"""
enum MatchesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  matches_pkey
}

"""
input type for inserting data into table "matches"
"""
input MatchesInsertInput {
  chatMessages: ChatMessagesArrRelInsertInput
  createdAt: timestamp
  goteType: PlayerType
  id: String
  matchStates: MatchStatesArrRelInsertInput
  playerGote: String
  playerSente: String
  senteType: PlayerType
  status: MatchStatus
  updatedAt: timestamp
}

"""
response of any mutation on the table "matches"
"""
type MatchesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Matches!]!
}

"""
input type for inserting object relation for remote table "matches"
"""
input MatchesObjRelInsertInput {
  data: MatchesInsertInput!

  """upsert condition"""
  onConflict: MatchesOnConflict
}

"""
on_conflict condition type for table "matches"
"""
input MatchesOnConflict {
  constraint: MatchesConstraint!
  updateColumns: [MatchesUpdateColumn!]! = []
  where: MatchesBoolExp
}

"""Ordering options when selecting data from "matches"."""
input MatchesOrderBy {
  chatMessagesAggregate: ChatMessagesAggregateOrderBy
  createdAt: OrderBy
  goteType: OrderBy
  id: OrderBy
  matchStatesAggregate: MatchStatesAggregateOrderBy
  playerGote: OrderBy
  playerSente: OrderBy
  senteType: OrderBy
  status: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: matches"""
input MatchesPkColumnsInput {
  id: String!
}

"""
select columns of table "matches"
"""
enum MatchesSelectColumn {
  """column name"""
  createdAt

  """column name"""
  goteType

  """column name"""
  id

  """column name"""
  playerGote

  """column name"""
  playerSente

  """column name"""
  senteType

  """column name"""
  status

  """column name"""
  updatedAt
}

"""
input type for updating data in table "matches"
"""
input MatchesSetInput {
  createdAt: timestamp
  goteType: PlayerType
  id: String
  playerGote: String
  playerSente: String
  senteType: PlayerType
  status: MatchStatus
  updatedAt: timestamp
}

"""
Streaming cursor of the table "matches"
"""
input MatchesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MatchesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MatchesStreamCursorValueInput {
  createdAt: timestamp
  goteType: PlayerType
  id: String
  playerGote: String
  playerSente: String
  senteType: PlayerType
  status: MatchStatus
  updatedAt: timestamp
}

"""
update columns of table "matches"
"""
enum MatchesUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  goteType

  """column name"""
  id

  """column name"""
  playerGote

  """column name"""
  playerSente

  """column name"""
  senteType

  """column name"""
  status

  """column name"""
  updatedAt
}

input MatchesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MatchesSetInput

  """filter the rows which have to be updated"""
  where: MatchesBoolExp!
}

"""対局状態"""
type MatchState {
  """作成日時"""
  createdAt: String!

  """局面番号"""
  index: Int!

  """対局ID"""
  matchId: String!

  """指し手（USI形式）"""
  moveNotation: String

  """手番プレイヤー"""
  player: String!

  """盤面（SFEN形式）"""
  sfen: String!

  """消費時間（秒）"""
  thinkingTime: Int
}

"""
columns and relationships of "match_states"
"""
type MatchStates {
  createdAt: timestamp!
  index: Int!

  """An object relationship"""
  match: Matches!
  matchId: String!
  moveNotation: String
  player: Player!
  sfen: String!
  thinkingTime: Int
}

"""
order by aggregate values of table "match_states"
"""
input MatchStatesAggregateOrderBy {
  avg: MatchStatesAvgOrderBy
  count: OrderBy
  max: MatchStatesMaxOrderBy
  min: MatchStatesMinOrderBy
  stddev: MatchStatesStddevOrderBy
  stddevPop: MatchStatesStddevPopOrderBy
  stddevSamp: MatchStatesStddevSampOrderBy
  sum: MatchStatesSumOrderBy
  varPop: MatchStatesVarPopOrderBy
  varSamp: MatchStatesVarSampOrderBy
  variance: MatchStatesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "match_states"
"""
input MatchStatesArrRelInsertInput {
  data: [MatchStatesInsertInput!]!

  """upsert condition"""
  onConflict: MatchStatesOnConflict
}

"""
order by avg() on columns of table "match_states"
"""
input MatchStatesAvgOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
Boolean expression to filter rows from the table "match_states". All fields are combined with a logical 'AND'.
"""
input MatchStatesBoolExp {
  _and: [MatchStatesBoolExp!]
  _not: MatchStatesBoolExp
  _or: [MatchStatesBoolExp!]
  createdAt: TimestampComparisonExp
  index: IntComparisonExp
  match: MatchesBoolExp
  matchId: StringComparisonExp
  moveNotation: StringComparisonExp
  player: PlayerComparisonExp
  sfen: StringComparisonExp
  thinkingTime: IntComparisonExp
}

"""
unique or primary key constraints on table "match_states"
"""
enum MatchStatesConstraint {
  """
  unique or primary key constraint on columns "index", "matchId"
  """
  match_states_pkey
}

"""
input type for incrementing numeric columns in table "match_states"
"""
input MatchStatesIncInput {
  index: Int
  thinkingTime: Int
}

"""
input type for inserting data into table "match_states"
"""
input MatchStatesInsertInput {
  createdAt: timestamp
  index: Int
  match: MatchesObjRelInsertInput
  matchId: String
  moveNotation: String
  player: Player
  sfen: String
  thinkingTime: Int
}

"""
order by max() on columns of table "match_states"
"""
input MatchStatesMaxOrderBy {
  createdAt: OrderBy
  index: OrderBy
  matchId: OrderBy
  moveNotation: OrderBy
  player: OrderBy
  sfen: OrderBy
  thinkingTime: OrderBy
}

"""
order by min() on columns of table "match_states"
"""
input MatchStatesMinOrderBy {
  createdAt: OrderBy
  index: OrderBy
  matchId: OrderBy
  moveNotation: OrderBy
  player: OrderBy
  sfen: OrderBy
  thinkingTime: OrderBy
}

"""
response of any mutation on the table "match_states"
"""
type MatchStatesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [MatchStates!]!
}

"""
on_conflict condition type for table "match_states"
"""
input MatchStatesOnConflict {
  constraint: MatchStatesConstraint!
  updateColumns: [MatchStatesUpdateColumn!]! = []
  where: MatchStatesBoolExp
}

"""Ordering options when selecting data from "match_states"."""
input MatchStatesOrderBy {
  createdAt: OrderBy
  index: OrderBy
  match: MatchesOrderBy
  matchId: OrderBy
  moveNotation: OrderBy
  player: OrderBy
  sfen: OrderBy
  thinkingTime: OrderBy
}

"""primary key columns input for table: match_states"""
input MatchStatesPkColumnsInput {
  index: Int!
  matchId: String!
}

"""
select columns of table "match_states"
"""
enum MatchStatesSelectColumn {
  """column name"""
  createdAt

  """column name"""
  index

  """column name"""
  matchId

  """column name"""
  moveNotation

  """column name"""
  player

  """column name"""
  sfen

  """column name"""
  thinkingTime
}

"""
input type for updating data in table "match_states"
"""
input MatchStatesSetInput {
  createdAt: timestamp
  index: Int
  matchId: String
  moveNotation: String
  player: Player
  sfen: String
  thinkingTime: Int
}

"""
order by stddev() on columns of table "match_states"
"""
input MatchStatesStddevOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by stddevPop() on columns of table "match_states"
"""
input MatchStatesStddevPopOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by stddevSamp() on columns of table "match_states"
"""
input MatchStatesStddevSampOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
Streaming cursor of the table "match_states"
"""
input MatchStatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MatchStatesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MatchStatesStreamCursorValueInput {
  createdAt: timestamp
  index: Int
  matchId: String
  moveNotation: String
  player: Player
  sfen: String
  thinkingTime: Int
}

"""
order by sum() on columns of table "match_states"
"""
input MatchStatesSumOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
update columns of table "match_states"
"""
enum MatchStatesUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  index

  """column name"""
  matchId

  """column name"""
  moveNotation

  """column name"""
  player

  """column name"""
  sfen

  """column name"""
  thinkingTime
}

input MatchStatesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: MatchStatesIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: MatchStatesSetInput

  """filter the rows which have to be updated"""
  where: MatchStatesBoolExp!
}

"""
order by variance() on columns of table "match_states"
"""
input MatchStatesVarianceOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by varPop() on columns of table "match_states"
"""
input MatchStatesVarPopOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by varSamp() on columns of table "match_states"
"""
input MatchStatesVarSampOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

scalar MatchStatus

"""
Boolean expression to compare columns of type "MatchStatus". All fields are combined with logical 'AND'.
"""
input MatchStatusComparisonExp {
  _eq: MatchStatus
  _gt: MatchStatus
  _gte: MatchStatus
  _in: [MatchStatus!]
  _isNull: Boolean
  _lt: MatchStatus
  _lte: MatchStatus
  _neq: MatchStatus
  _nin: [MatchStatus!]
}

"""メッセージコンテンツのUnion型"""
union MessageContent = BestMoveContent | MarkdownContent

scalar MessageRole

"""
Boolean expression to compare columns of type "MessageRole". All fields are combined with logical 'AND'.
"""
input MessageRoleComparisonExp {
  _eq: MessageRole
  _gt: MessageRole
  _gte: MessageRole
  _in: [MessageRole!]
  _isNull: Boolean
  _lt: MessageRole
  _lte: MessageRole
  _neq: MessageRole
  _nin: [MessageRole!]
}

"""1つの候補手情報"""
type MoveVariation {
  """探索深さ"""
  depth: Int!

  """指し手（USI形式）"""
  move: String!

  """探索ノード数"""
  nodes: Int

  """読み筋（PV）"""
  pv: [String!]

  """評価値（センチポーン）"""
  scoreCp: Int

  """詰みまでの手数（プライ数）"""
  scoreMate: Int
}

"""mutation root"""
type mutation_root {
  createMatch(input: CreateMatchInput!): Match!

  """
  delete data from the table: "chat_messages"
  """
  deleteChatMessages(
    """filter the rows which have to be deleted"""
    where: ChatMessagesBoolExp!
  ): ChatMessagesMutationResponse

  """
  delete single row from the table: "chat_messages"
  """
  deleteChatMessagesByPk(id: String!): ChatMessages

  """
  delete data from the table: "match_states"
  """
  deleteMatchStates(
    """filter the rows which have to be deleted"""
    where: MatchStatesBoolExp!
  ): MatchStatesMutationResponse

  """
  delete single row from the table: "match_states"
  """
  deleteMatchStatesByPk(index: Int!, matchId: String!): MatchStates

  """
  delete data from the table: "matches"
  """
  deleteMatches(
    """filter the rows which have to be deleted"""
    where: MatchesBoolExp!
  ): MatchesMutationResponse

  """
  delete single row from the table: "matches"
  """
  deleteMatchesByPk(id: String!): Matches
  evaluateMatchState(input: EvaluateMatchStateInput!): EvaluateMatchStateResult!

  """
  insert data into the table: "chat_messages"
  """
  insertChatMessages(
    """the rows to be inserted"""
    objects: [ChatMessagesInsertInput!]!

    """upsert condition"""
    onConflict: ChatMessagesOnConflict
  ): ChatMessagesMutationResponse

  """
  insert a single row into the table: "chat_messages"
  """
  insertChatMessagesOne(
    """the row to be inserted"""
    object: ChatMessagesInsertInput!

    """upsert condition"""
    onConflict: ChatMessagesOnConflict
  ): ChatMessages

  """
  insert data into the table: "match_states"
  """
  insertMatchStates(
    """the rows to be inserted"""
    objects: [MatchStatesInsertInput!]!

    """upsert condition"""
    onConflict: MatchStatesOnConflict
  ): MatchStatesMutationResponse

  """
  insert a single row into the table: "match_states"
  """
  insertMatchStatesOne(
    """the row to be inserted"""
    object: MatchStatesInsertInput!

    """upsert condition"""
    onConflict: MatchStatesOnConflict
  ): MatchStates

  """
  insert data into the table: "matches"
  """
  insertMatches(
    """the rows to be inserted"""
    objects: [MatchesInsertInput!]!

    """upsert condition"""
    onConflict: MatchesOnConflict
  ): MatchesMutationResponse

  """
  insert a single row into the table: "matches"
  """
  insertMatchesOne(
    """the row to be inserted"""
    object: MatchesInsertInput!

    """upsert condition"""
    onConflict: MatchesOnConflict
  ): Matches
  saveMatchStateAndGetCandidates(input: SaveMatchStateInput!): SaveMatchStateResult!
  sendChatMessage(input: SendChatMessageInput!): SendChatMessageResult!

  """
  update data of the table: "chat_messages"
  """
  updateChatMessages(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ChatMessagesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ChatMessagesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _deleteElem: ChatMessagesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ChatMessagesDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ChatMessagesPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatMessagesSetInput

    """filter the rows which have to be updated"""
    where: ChatMessagesBoolExp!
  ): ChatMessagesMutationResponse

  """
  update single row of the table: "chat_messages"
  """
  updateChatMessagesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ChatMessagesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ChatMessagesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _deleteElem: ChatMessagesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ChatMessagesDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ChatMessagesPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatMessagesSetInput
    pkColumns: ChatMessagesPkColumnsInput!
  ): ChatMessages

  """
  update multiples rows of table: "chat_messages"
  """
  updateChatMessagesMany(
    """updates to execute, in order"""
    updates: [ChatMessagesUpdates!]!
  ): [ChatMessagesMutationResponse]

  """
  update data of the table: "match_states"
  """
  updateMatchStates(
    """increments the numeric columns with given value of the filtered values"""
    _inc: MatchStatesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: MatchStatesSetInput

    """filter the rows which have to be updated"""
    where: MatchStatesBoolExp!
  ): MatchStatesMutationResponse

  """
  update single row of the table: "match_states"
  """
  updateMatchStatesByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: MatchStatesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: MatchStatesSetInput
    pkColumns: MatchStatesPkColumnsInput!
  ): MatchStates

  """
  update multiples rows of table: "match_states"
  """
  updateMatchStatesMany(
    """updates to execute, in order"""
    updates: [MatchStatesUpdates!]!
  ): [MatchStatesMutationResponse]

  """
  update data of the table: "matches"
  """
  updateMatches(
    """sets the columns of the filtered rows to the given values"""
    _set: MatchesSetInput

    """filter the rows which have to be updated"""
    where: MatchesBoolExp!
  ): MatchesMutationResponse

  """
  update single row of the table: "matches"
  """
  updateMatchesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MatchesSetInput
    pkColumns: MatchesPkColumnsInput!
  ): Matches

  """
  update multiples rows of table: "matches"
  """
  updateMatchesMany(
    """updates to execute, in order"""
    updates: [MatchesUpdates!]!
  ): [MatchesMutationResponse]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

scalar Player

"""
Boolean expression to compare columns of type "Player". All fields are combined with logical 'AND'.
"""
input PlayerComparisonExp {
  _eq: Player
  _gt: Player
  _gte: Player
  _in: [Player!]
  _isNull: Boolean
  _lt: Player
  _lte: Player
  _neq: Player
  _nin: [Player!]
}

scalar PlayerType

"""
Boolean expression to compare columns of type "PlayerType". All fields are combined with logical 'AND'.
"""
input PlayerTypeComparisonExp {
  _eq: PlayerType
  _gt: PlayerType
  _gte: PlayerType
  _in: [PlayerType!]
  _isNull: Boolean
  _lt: PlayerType
  _lte: PlayerType
  _neq: PlayerType
  _nin: [PlayerType!]
}

type query_root {
  """An array relationship"""
  chatMessages(
    """distinct select on columns"""
    distinctOn: [ChatMessagesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatMessagesOrderBy!]

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!

  """fetch data from the table: "chat_messages" using primary key columns"""
  chatMessagesByPk(id: String!): ChatMessages
  health: Health!

  """An array relationship"""
  matchStates(
    """distinct select on columns"""
    distinctOn: [MatchStatesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchStatesOrderBy!]

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!

  """fetch data from the table: "match_states" using primary key columns"""
  matchStatesByPk(index: Int!, matchId: String!): MatchStates

  """
  fetch data from the table: "matches"
  """
  matches(
    """distinct select on columns"""
    distinctOn: [MatchesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchesOrderBy!]

    """filter the rows returned"""
    where: MatchesBoolExp
  ): [Matches!]!

  """fetch data from the table: "matches" using primary key columns"""
  matchesByPk(id: String!): Matches
}

"""対局状態保存リクエスト"""
input SaveMatchStateInput {
  """局面番号（何手目か）"""
  index: Int!

  """対局ID"""
  matchId: String!

  """この局面に至った指し手（USI形式）"""
  moveNotation: String

  """候補手の数（MultiPV、デフォルト: 3）"""
  multipv: Int

  """この盤面での手番プレイヤー（SENTE/GOTE）"""
  player: String!

  """盤面（SFEN形式）"""
  sfen: String!

  """消費時間（秒）"""
  thinkingTime: Int

  """思考時間（ミリ秒、デフォルト: 1000）"""
  timeMs: Int
}

"""対局状態保存結果"""
type SaveMatchStateResult {
  """次の候補手リスト"""
  candidates: [MoveVariation!]!

  """保存された対局状態"""
  matchState: MatchState!
}

"""チャットメッセージ送信リクエスト"""
input SendChatMessageInput {
  """メッセージ内容"""
  content: String!

  """対局ID"""
  matchId: String!
}

"""チャットメッセージ送信結果"""
type SendChatMessageResult {
  """AIアシスタントの応答メッセージ"""
  assistantMessage: ChatMessage!

  """作成されたユーザーメッセージ"""
  userMessage: ChatMessage!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """An array relationship"""
  chatMessages(
    """distinct select on columns"""
    distinctOn: [ChatMessagesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatMessagesOrderBy!]

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!

  """fetch data from the table: "chat_messages" using primary key columns"""
  chatMessagesByPk(id: String!): ChatMessages

  """
  fetch data from the table in a streaming manner: "chat_messages"
  """
  chatMessagesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatMessagesStreamCursorInput]!

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!

  """An array relationship"""
  matchStates(
    """distinct select on columns"""
    distinctOn: [MatchStatesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchStatesOrderBy!]

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!

  """fetch data from the table: "match_states" using primary key columns"""
  matchStatesByPk(index: Int!, matchId: String!): MatchStates

  """
  fetch data from the table in a streaming manner: "match_states"
  """
  matchStatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MatchStatesStreamCursorInput]!

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!

  """
  fetch data from the table: "matches"
  """
  matches(
    """distinct select on columns"""
    distinctOn: [MatchesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchesOrderBy!]

    """filter the rows returned"""
    where: MatchesBoolExp
  ): [Matches!]!

  """fetch data from the table: "matches" using primary key columns"""
  matchesByPk(id: String!): Matches

  """
  fetch data from the table in a streaming manner: "matches"
  """
  matchesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MatchesStreamCursorInput]!

    """filter the rows returned"""
    where: MatchesBoolExp
  ): [Matches!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input TimestampComparisonExp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _isNull: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

