schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""AIプロンプトのパーソナリティ設定"""
enum AiPersonality {
  """常に煽る"""
  always

  """煽りなし"""
  none

  """戦況に応じて煽る"""
  situational
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "chat_messages"
"""
type ChatMessages {
  contents(
    """JSON select path"""
    path: String
  ): jsonb!
  createdAt: timestamp!
  id: String!
  isPartial: Boolean!

  """An object relationship"""
  match: Matches!
  matchId: String!
  metadata: String
  role: MessageRole!
  updatedAt: timestamp!
}

"""
order by aggregate values of table "chat_messages"
"""
input ChatMessagesAggregateOrderBy {
  count: OrderBy
  max: ChatMessagesMaxOrderBy
  min: ChatMessagesMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ChatMessagesAppendInput {
  contents: jsonb
}

"""
input type for inserting array relation for remote table "chat_messages"
"""
input ChatMessagesArrRelInsertInput {
  data: [ChatMessagesInsertInput!]!

  """upsert condition"""
  onConflict: ChatMessagesOnConflict
}

"""
Boolean expression to filter rows from the table "chat_messages". All fields are combined with a logical 'AND'.
"""
input ChatMessagesBoolExp {
  _and: [ChatMessagesBoolExp!]
  _not: ChatMessagesBoolExp
  _or: [ChatMessagesBoolExp!]
  contents: JsonbComparisonExp
  createdAt: TimestampComparisonExp
  id: StringComparisonExp
  isPartial: BooleanComparisonExp
  match: MatchesBoolExp
  matchId: StringComparisonExp
  metadata: StringComparisonExp
  role: MessageRoleComparisonExp
  updatedAt: TimestampComparisonExp
}

"""
unique or primary key constraints on table "chat_messages"
"""
enum ChatMessagesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  chat_messages_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ChatMessagesDeleteAtPathInput {
  contents: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input ChatMessagesDeleteElemInput {
  contents: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ChatMessagesDeleteKeyInput {
  contents: String
}

"""
input type for inserting data into table "chat_messages"
"""
input ChatMessagesInsertInput {
  contents: jsonb
  createdAt: timestamp
  id: String
  isPartial: Boolean
  match: MatchesObjRelInsertInput
  matchId: String
  metadata: String
  role: MessageRole
  updatedAt: timestamp
}

"""
order by max() on columns of table "chat_messages"
"""
input ChatMessagesMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  matchId: OrderBy
  metadata: OrderBy
  role: OrderBy
  updatedAt: OrderBy
}

"""
order by min() on columns of table "chat_messages"
"""
input ChatMessagesMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  matchId: OrderBy
  metadata: OrderBy
  role: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "chat_messages"
"""
type ChatMessagesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ChatMessages!]!
}

"""
on_conflict condition type for table "chat_messages"
"""
input ChatMessagesOnConflict {
  constraint: ChatMessagesConstraint!
  updateColumns: [ChatMessagesUpdateColumn!]! = []
  where: ChatMessagesBoolExp
}

"""Ordering options when selecting data from "chat_messages"."""
input ChatMessagesOrderBy {
  contents: OrderBy
  createdAt: OrderBy
  id: OrderBy
  isPartial: OrderBy
  match: MatchesOrderBy
  matchId: OrderBy
  metadata: OrderBy
  role: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: chat_messages"""
input ChatMessagesPkColumnsInput {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ChatMessagesPrependInput {
  contents: jsonb
}

"""
select columns of table "chat_messages"
"""
enum ChatMessagesSelectColumn {
  """column name"""
  contents

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPartial

  """column name"""
  matchId

  """column name"""
  metadata

  """column name"""
  role

  """column name"""
  updatedAt
}

"""
input type for updating data in table "chat_messages"
"""
input ChatMessagesSetInput {
  contents: jsonb
  createdAt: timestamp
  id: String
  isPartial: Boolean
  matchId: String
  metadata: String
  role: MessageRole
  updatedAt: timestamp
}

"""
Streaming cursor of the table "chat_messages"
"""
input ChatMessagesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ChatMessagesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ChatMessagesStreamCursorValueInput {
  contents: jsonb
  createdAt: timestamp
  id: String
  isPartial: Boolean
  matchId: String
  metadata: String
  role: MessageRole
  updatedAt: timestamp
}

"""
update columns of table "chat_messages"
"""
enum ChatMessagesUpdateColumn {
  """column name"""
  contents

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPartial

  """column name"""
  matchId

  """column name"""
  metadata

  """column name"""
  role

  """column name"""
  updatedAt
}

input ChatMessagesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ChatMessagesAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ChatMessagesDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _deleteElem: ChatMessagesDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ChatMessagesDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ChatMessagesPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ChatMessagesSetInput

  """filter the rows which have to be updated"""
  where: ChatMessagesBoolExp!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "evaluations"
"""
type Evaluations {
  createdAt: timestamp!
  engineName: String!
  id: String!
  sfen: String!
  updatedAt: timestamp!
  variations(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input EvaluationsAppendInput {
  variations: jsonb
}

"""
Boolean expression to filter rows from the table "evaluations". All fields are combined with a logical 'AND'.
"""
input EvaluationsBoolExp {
  _and: [EvaluationsBoolExp!]
  _not: EvaluationsBoolExp
  _or: [EvaluationsBoolExp!]
  createdAt: TimestampComparisonExp
  engineName: StringComparisonExp
  id: StringComparisonExp
  sfen: StringComparisonExp
  updatedAt: TimestampComparisonExp
  variations: JsonbComparisonExp
}

"""
unique or primary key constraints on table "evaluations"
"""
enum EvaluationsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  evaluations_pkey

  """
  unique or primary key constraint on columns "engineName", "sfen"
  """
  evaluations_sfen_engineName_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input EvaluationsDeleteAtPathInput {
  variations: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input EvaluationsDeleteElemInput {
  variations: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input EvaluationsDeleteKeyInput {
  variations: String
}

"""
input type for inserting data into table "evaluations"
"""
input EvaluationsInsertInput {
  createdAt: timestamp
  engineName: String
  id: String
  sfen: String
  updatedAt: timestamp
  variations: jsonb
}

"""
response of any mutation on the table "evaluations"
"""
type EvaluationsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Evaluations!]!
}

"""
on_conflict condition type for table "evaluations"
"""
input EvaluationsOnConflict {
  constraint: EvaluationsConstraint!
  updateColumns: [EvaluationsUpdateColumn!]! = []
  where: EvaluationsBoolExp
}

"""Ordering options when selecting data from "evaluations"."""
input EvaluationsOrderBy {
  createdAt: OrderBy
  engineName: OrderBy
  id: OrderBy
  sfen: OrderBy
  updatedAt: OrderBy
  variations: OrderBy
}

"""primary key columns input for table: evaluations"""
input EvaluationsPkColumnsInput {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input EvaluationsPrependInput {
  variations: jsonb
}

"""
select columns of table "evaluations"
"""
enum EvaluationsSelectColumn {
  """column name"""
  createdAt

  """column name"""
  engineName

  """column name"""
  id

  """column name"""
  sfen

  """column name"""
  updatedAt

  """column name"""
  variations
}

"""
input type for updating data in table "evaluations"
"""
input EvaluationsSetInput {
  createdAt: timestamp
  engineName: String
  id: String
  sfen: String
  updatedAt: timestamp
  variations: jsonb
}

"""
Streaming cursor of the table "evaluations"
"""
input EvaluationsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EvaluationsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EvaluationsStreamCursorValueInput {
  createdAt: timestamp
  engineName: String
  id: String
  sfen: String
  updatedAt: timestamp
  variations: jsonb
}

"""
update columns of table "evaluations"
"""
enum EvaluationsUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  engineName

  """column name"""
  id

  """column name"""
  sfen

  """column name"""
  updatedAt

  """column name"""
  variations
}

input EvaluationsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: EvaluationsAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: EvaluationsDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _deleteElem: EvaluationsDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: EvaluationsDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: EvaluationsPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: EvaluationsSetInput

  """filter the rows which have to be updated"""
  where: EvaluationsBoolExp!
}

"""対局分岐リクエスト"""
input ForkMatchInput {
  """分岐する手数インデックス"""
  fromIndex: Int!

  """元の対局ID"""
  matchId: String!
}

type Health {
  status: String!
  timestamp: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""対局情報"""
type Match {
  """作成日時"""
  createdAt: String!

  """後手のプレイヤータイプ"""
  goteType: PlayerType!

  """対局ID"""
  id: String!

  """後手のプレイヤー名"""
  playerGote: String

  """先手のプレイヤー名"""
  playerSente: String

  """先手のプレイヤータイプ"""
  senteType: PlayerType!

  """対局状況"""
  status: String!

  """更新日時"""
  updatedAt: String!
}

"""
columns and relationships of "matches"
"""
type Matches {
  """An array relationship"""
  chatMessages(
    """distinct select on columns"""
    distinctOn: [ChatMessagesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatMessagesOrderBy!]

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!
  createdAt: timestamp!
  goteType: PlayerType!
  id: String!

  """An array relationship"""
  matchStates(
    """distinct select on columns"""
    distinctOn: [MatchStatesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchStatesOrderBy!]

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!
  playerGote: String
  playerSente: String
  senteType: PlayerType!
  status: MatchStatus!
  updatedAt: timestamp!
}

"""
Boolean expression to filter rows from the table "matches". All fields are combined with a logical 'AND'.
"""
input MatchesBoolExp {
  _and: [MatchesBoolExp!]
  _not: MatchesBoolExp
  _or: [MatchesBoolExp!]
  chatMessages: ChatMessagesBoolExp
  createdAt: TimestampComparisonExp
  goteType: PlayerTypeComparisonExp
  id: StringComparisonExp
  matchStates: MatchStatesBoolExp
  playerGote: StringComparisonExp
  playerSente: StringComparisonExp
  senteType: PlayerTypeComparisonExp
  status: MatchStatusComparisonExp
  updatedAt: TimestampComparisonExp
}

"""
unique or primary key constraints on table "matches"
"""
enum MatchesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  matches_pkey
}

"""
input type for inserting data into table "matches"
"""
input MatchesInsertInput {
  chatMessages: ChatMessagesArrRelInsertInput
  createdAt: timestamp
  goteType: PlayerType
  id: String
  matchStates: MatchStatesArrRelInsertInput
  playerGote: String
  playerSente: String
  senteType: PlayerType
  status: MatchStatus
  updatedAt: timestamp
}

"""
response of any mutation on the table "matches"
"""
type MatchesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Matches!]!
}

"""
input type for inserting object relation for remote table "matches"
"""
input MatchesObjRelInsertInput {
  data: MatchesInsertInput!

  """upsert condition"""
  onConflict: MatchesOnConflict
}

"""
on_conflict condition type for table "matches"
"""
input MatchesOnConflict {
  constraint: MatchesConstraint!
  updateColumns: [MatchesUpdateColumn!]! = []
  where: MatchesBoolExp
}

"""Ordering options when selecting data from "matches"."""
input MatchesOrderBy {
  chatMessagesAggregate: ChatMessagesAggregateOrderBy
  createdAt: OrderBy
  goteType: OrderBy
  id: OrderBy
  matchStatesAggregate: MatchStatesAggregateOrderBy
  playerGote: OrderBy
  playerSente: OrderBy
  senteType: OrderBy
  status: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: matches"""
input MatchesPkColumnsInput {
  id: String!
}

"""
select columns of table "matches"
"""
enum MatchesSelectColumn {
  """column name"""
  createdAt

  """column name"""
  goteType

  """column name"""
  id

  """column name"""
  playerGote

  """column name"""
  playerSente

  """column name"""
  senteType

  """column name"""
  status

  """column name"""
  updatedAt
}

"""
input type for updating data in table "matches"
"""
input MatchesSetInput {
  createdAt: timestamp
  goteType: PlayerType
  id: String
  playerGote: String
  playerSente: String
  senteType: PlayerType
  status: MatchStatus
  updatedAt: timestamp
}

"""
Streaming cursor of the table "matches"
"""
input MatchesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MatchesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MatchesStreamCursorValueInput {
  createdAt: timestamp
  goteType: PlayerType
  id: String
  playerGote: String
  playerSente: String
  senteType: PlayerType
  status: MatchStatus
  updatedAt: timestamp
}

"""
update columns of table "matches"
"""
enum MatchesUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  goteType

  """column name"""
  id

  """column name"""
  playerGote

  """column name"""
  playerSente

  """column name"""
  senteType

  """column name"""
  status

  """column name"""
  updatedAt
}

input MatchesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MatchesSetInput

  """filter the rows which have to be updated"""
  where: MatchesBoolExp!
}

"""対局の評価値（手番ごと）"""
type MatchEvaluation {
  """手番インデックス"""
  moveIndex: Int!

  """評価値（センチポーン）"""
  scoreCp: Int

  """詰みまでの手数"""
  scoreMate: Int
}

"""
columns and relationships of "match_states"
"""
type MatchStates {
  createdAt: timestamp!
  index: Int!

  """An object relationship"""
  match: Matches!
  matchId: String!
  sfen: String!
  thinkingTime: Int
  usiMove: String!
}

"""
order by aggregate values of table "match_states"
"""
input MatchStatesAggregateOrderBy {
  avg: MatchStatesAvgOrderBy
  count: OrderBy
  max: MatchStatesMaxOrderBy
  min: MatchStatesMinOrderBy
  stddev: MatchStatesStddevOrderBy
  stddevPop: MatchStatesStddevPopOrderBy
  stddevSamp: MatchStatesStddevSampOrderBy
  sum: MatchStatesSumOrderBy
  varPop: MatchStatesVarPopOrderBy
  varSamp: MatchStatesVarSampOrderBy
  variance: MatchStatesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "match_states"
"""
input MatchStatesArrRelInsertInput {
  data: [MatchStatesInsertInput!]!

  """upsert condition"""
  onConflict: MatchStatesOnConflict
}

"""
order by avg() on columns of table "match_states"
"""
input MatchStatesAvgOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
Boolean expression to filter rows from the table "match_states". All fields are combined with a logical 'AND'.
"""
input MatchStatesBoolExp {
  _and: [MatchStatesBoolExp!]
  _not: MatchStatesBoolExp
  _or: [MatchStatesBoolExp!]
  createdAt: TimestampComparisonExp
  index: IntComparisonExp
  match: MatchesBoolExp
  matchId: StringComparisonExp
  sfen: StringComparisonExp
  thinkingTime: IntComparisonExp
  usiMove: StringComparisonExp
}

"""
unique or primary key constraints on table "match_states"
"""
enum MatchStatesConstraint {
  """
  unique or primary key constraint on columns "index", "matchId"
  """
  match_states_pkey
}

"""
input type for incrementing numeric columns in table "match_states"
"""
input MatchStatesIncInput {
  index: Int
  thinkingTime: Int
}

"""
input type for inserting data into table "match_states"
"""
input MatchStatesInsertInput {
  createdAt: timestamp
  index: Int
  match: MatchesObjRelInsertInput
  matchId: String
  sfen: String
  thinkingTime: Int
  usiMove: String
}

"""
order by max() on columns of table "match_states"
"""
input MatchStatesMaxOrderBy {
  createdAt: OrderBy
  index: OrderBy
  matchId: OrderBy
  sfen: OrderBy
  thinkingTime: OrderBy
  usiMove: OrderBy
}

"""
order by min() on columns of table "match_states"
"""
input MatchStatesMinOrderBy {
  createdAt: OrderBy
  index: OrderBy
  matchId: OrderBy
  sfen: OrderBy
  thinkingTime: OrderBy
  usiMove: OrderBy
}

"""
response of any mutation on the table "match_states"
"""
type MatchStatesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [MatchStates!]!
}

"""
on_conflict condition type for table "match_states"
"""
input MatchStatesOnConflict {
  constraint: MatchStatesConstraint!
  updateColumns: [MatchStatesUpdateColumn!]! = []
  where: MatchStatesBoolExp
}

"""Ordering options when selecting data from "match_states"."""
input MatchStatesOrderBy {
  createdAt: OrderBy
  index: OrderBy
  match: MatchesOrderBy
  matchId: OrderBy
  sfen: OrderBy
  thinkingTime: OrderBy
  usiMove: OrderBy
}

"""primary key columns input for table: match_states"""
input MatchStatesPkColumnsInput {
  index: Int!
  matchId: String!
}

"""
select columns of table "match_states"
"""
enum MatchStatesSelectColumn {
  """column name"""
  createdAt

  """column name"""
  index

  """column name"""
  matchId

  """column name"""
  sfen

  """column name"""
  thinkingTime

  """column name"""
  usiMove
}

"""
input type for updating data in table "match_states"
"""
input MatchStatesSetInput {
  createdAt: timestamp
  index: Int
  matchId: String
  sfen: String
  thinkingTime: Int
  usiMove: String
}

"""
order by stddev() on columns of table "match_states"
"""
input MatchStatesStddevOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by stddevPop() on columns of table "match_states"
"""
input MatchStatesStddevPopOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by stddevSamp() on columns of table "match_states"
"""
input MatchStatesStddevSampOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
Streaming cursor of the table "match_states"
"""
input MatchStatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MatchStatesStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MatchStatesStreamCursorValueInput {
  createdAt: timestamp
  index: Int
  matchId: String
  sfen: String
  thinkingTime: Int
  usiMove: String
}

"""
order by sum() on columns of table "match_states"
"""
input MatchStatesSumOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
update columns of table "match_states"
"""
enum MatchStatesUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  index

  """column name"""
  matchId

  """column name"""
  sfen

  """column name"""
  thinkingTime

  """column name"""
  usiMove
}

input MatchStatesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: MatchStatesIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: MatchStatesSetInput

  """filter the rows which have to be updated"""
  where: MatchStatesBoolExp!
}

"""
order by variance() on columns of table "match_states"
"""
input MatchStatesVarianceOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by varPop() on columns of table "match_states"
"""
input MatchStatesVarPopOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

"""
order by varSamp() on columns of table "match_states"
"""
input MatchStatesVarSampOrderBy {
  index: OrderBy
  thinkingTime: OrderBy
}

scalar MatchStatus

"""
Boolean expression to compare columns of type "MatchStatus". All fields are combined with logical 'AND'.
"""
input MatchStatusComparisonExp {
  _eq: MatchStatus
  _gt: MatchStatus
  _gte: MatchStatus
  _in: [MatchStatus!]
  _isNull: Boolean
  _lt: MatchStatus
  _lte: MatchStatus
  _neq: MatchStatus
  _nin: [MatchStatus!]
}

scalar MessageRole

"""
Boolean expression to compare columns of type "MessageRole". All fields are combined with logical 'AND'.
"""
input MessageRoleComparisonExp {
  _eq: MessageRole
  _gt: MessageRole
  _gte: MessageRole
  _in: [MessageRole!]
  _isNull: Boolean
  _lt: MessageRole
  _lte: MessageRole
  _neq: MessageRole
  _nin: [MessageRole!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "chat_messages"
  """
  deleteChatMessages(
    """filter the rows which have to be deleted"""
    where: ChatMessagesBoolExp!
  ): ChatMessagesMutationResponse

  """
  delete single row from the table: "chat_messages"
  """
  deleteChatMessagesByPk(id: String!): ChatMessages

  """
  delete data from the table: "evaluations"
  """
  deleteEvaluations(
    """filter the rows which have to be deleted"""
    where: EvaluationsBoolExp!
  ): EvaluationsMutationResponse

  """
  delete single row from the table: "evaluations"
  """
  deleteEvaluationsByPk(id: String!): Evaluations

  """
  delete data from the table: "match_states"
  """
  deleteMatchStates(
    """filter the rows which have to be deleted"""
    where: MatchStatesBoolExp!
  ): MatchStatesMutationResponse

  """
  delete single row from the table: "match_states"
  """
  deleteMatchStatesByPk(index: Int!, matchId: String!): MatchStates

  """
  delete data from the table: "matches"
  """
  deleteMatches(
    """filter the rows which have to be deleted"""
    where: MatchesBoolExp!
  ): MatchesMutationResponse

  """
  delete single row from the table: "matches"
  """
  deleteMatchesByPk(id: String!): Matches

  """対局を分岐して新しい対局を作成する"""
  forkMatch(input: ForkMatchInput!): Match!

  """
  insert data into the table: "chat_messages"
  """
  insertChatMessages(
    """the rows to be inserted"""
    objects: [ChatMessagesInsertInput!]!

    """upsert condition"""
    onConflict: ChatMessagesOnConflict
  ): ChatMessagesMutationResponse

  """
  insert a single row into the table: "chat_messages"
  """
  insertChatMessagesOne(
    """the row to be inserted"""
    object: ChatMessagesInsertInput!

    """upsert condition"""
    onConflict: ChatMessagesOnConflict
  ): ChatMessages

  """
  insert data into the table: "evaluations"
  """
  insertEvaluations(
    """the rows to be inserted"""
    objects: [EvaluationsInsertInput!]!

    """upsert condition"""
    onConflict: EvaluationsOnConflict
  ): EvaluationsMutationResponse

  """
  insert a single row into the table: "evaluations"
  """
  insertEvaluationsOne(
    """the row to be inserted"""
    object: EvaluationsInsertInput!

    """upsert condition"""
    onConflict: EvaluationsOnConflict
  ): Evaluations

  """
  insert data into the table: "match_states"
  """
  insertMatchStates(
    """the rows to be inserted"""
    objects: [MatchStatesInsertInput!]!

    """upsert condition"""
    onConflict: MatchStatesOnConflict
  ): MatchStatesMutationResponse

  """
  insert a single row into the table: "match_states"
  """
  insertMatchStatesOne(
    """the row to be inserted"""
    object: MatchStatesInsertInput!

    """upsert condition"""
    onConflict: MatchStatesOnConflict
  ): MatchStates

  """
  insert data into the table: "matches"
  """
  insertMatches(
    """the rows to be inserted"""
    objects: [MatchesInsertInput!]!

    """upsert condition"""
    onConflict: MatchesOnConflict
  ): MatchesMutationResponse

  """
  insert a single row into the table: "matches"
  """
  insertMatchesOne(
    """the row to be inserted"""
    object: MatchesInsertInput!

    """upsert condition"""
    onConflict: MatchesOnConflict
  ): Matches

  """対局を指定した手数まで巻き戻す"""
  rewindMatch(input: RewindMatchInput!): Match!
  sendChatMessage(input: SendChatMessageInput!): SendChatMessageResult!
  startMatch(input: StartMatchInput!): Match!

  """
  update data of the table: "chat_messages"
  """
  updateChatMessages(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ChatMessagesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ChatMessagesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _deleteElem: ChatMessagesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ChatMessagesDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ChatMessagesPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatMessagesSetInput

    """filter the rows which have to be updated"""
    where: ChatMessagesBoolExp!
  ): ChatMessagesMutationResponse

  """
  update single row of the table: "chat_messages"
  """
  updateChatMessagesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ChatMessagesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ChatMessagesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _deleteElem: ChatMessagesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ChatMessagesDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ChatMessagesPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ChatMessagesSetInput
    pkColumns: ChatMessagesPkColumnsInput!
  ): ChatMessages

  """
  update multiples rows of table: "chat_messages"
  """
  updateChatMessagesMany(
    """updates to execute, in order"""
    updates: [ChatMessagesUpdates!]!
  ): [ChatMessagesMutationResponse]

  """
  update data of the table: "evaluations"
  """
  updateEvaluations(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EvaluationsAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EvaluationsDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _deleteElem: EvaluationsDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EvaluationsDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EvaluationsPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: EvaluationsSetInput

    """filter the rows which have to be updated"""
    where: EvaluationsBoolExp!
  ): EvaluationsMutationResponse

  """
  update single row of the table: "evaluations"
  """
  updateEvaluationsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EvaluationsAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EvaluationsDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _deleteElem: EvaluationsDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EvaluationsDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EvaluationsPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: EvaluationsSetInput
    pkColumns: EvaluationsPkColumnsInput!
  ): Evaluations

  """
  update multiples rows of table: "evaluations"
  """
  updateEvaluationsMany(
    """updates to execute, in order"""
    updates: [EvaluationsUpdates!]!
  ): [EvaluationsMutationResponse]

  """
  update data of the table: "match_states"
  """
  updateMatchStates(
    """increments the numeric columns with given value of the filtered values"""
    _inc: MatchStatesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: MatchStatesSetInput

    """filter the rows which have to be updated"""
    where: MatchStatesBoolExp!
  ): MatchStatesMutationResponse

  """
  update single row of the table: "match_states"
  """
  updateMatchStatesByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: MatchStatesIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: MatchStatesSetInput
    pkColumns: MatchStatesPkColumnsInput!
  ): MatchStates

  """
  update multiples rows of table: "match_states"
  """
  updateMatchStatesMany(
    """updates to execute, in order"""
    updates: [MatchStatesUpdates!]!
  ): [MatchStatesMutationResponse]

  """
  update data of the table: "matches"
  """
  updateMatches(
    """sets the columns of the filtered rows to the given values"""
    _set: MatchesSetInput

    """filter the rows which have to be updated"""
    where: MatchesBoolExp!
  ): MatchesMutationResponse

  """
  update single row of the table: "matches"
  """
  updateMatchesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MatchesSetInput
    pkColumns: MatchesPkColumnsInput!
  ): Matches

  """
  update multiples rows of table: "matches"
  """
  updateMatchesMany(
    """updates to execute, in order"""
    updates: [MatchesUpdates!]!
  ): [MatchesMutationResponse]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

scalar PlayerType

"""
Boolean expression to compare columns of type "PlayerType". All fields are combined with logical 'AND'.
"""
input PlayerTypeComparisonExp {
  _eq: PlayerType
  _gt: PlayerType
  _gte: PlayerType
  _in: [PlayerType!]
  _isNull: Boolean
  _lt: PlayerType
  _lte: PlayerType
  _neq: PlayerType
  _nin: [PlayerType!]
}

type query_root {
  """An array relationship"""
  chatMessages(
    """distinct select on columns"""
    distinctOn: [ChatMessagesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatMessagesOrderBy!]

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!

  """fetch data from the table: "chat_messages" using primary key columns"""
  chatMessagesByPk(id: String!): ChatMessages

  """
  fetch data from the table: "evaluations"
  """
  evaluations(
    """distinct select on columns"""
    distinctOn: [EvaluationsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EvaluationsOrderBy!]

    """filter the rows returned"""
    where: EvaluationsBoolExp
  ): [Evaluations!]!

  """fetch data from the table: "evaluations" using primary key columns"""
  evaluationsByPk(id: String!): Evaluations
  health: Health!

  """対局の評価値遷移を取得"""
  matchEvaluations(matchId: String!): [MatchEvaluation!]!

  """An array relationship"""
  matchStates(
    """distinct select on columns"""
    distinctOn: [MatchStatesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchStatesOrderBy!]

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!

  """fetch data from the table: "match_states" using primary key columns"""
  matchStatesByPk(index: Int!, matchId: String!): MatchStates

  """
  fetch data from the table: "matches"
  """
  matches(
    """distinct select on columns"""
    distinctOn: [MatchesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchesOrderBy!]

    """filter the rows returned"""
    where: MatchesBoolExp
  ): [Matches!]!

  """fetch data from the table: "matches" using primary key columns"""
  matchesByPk(id: String!): Matches
}

"""対局巻き戻しリクエスト"""
input RewindMatchInput {
  """対局ID"""
  matchId: String!

  """巻き戻す先の手数インデックス"""
  toIndex: Int!
}

"""チャットメッセージ送信リクエスト"""
input SendChatMessageInput {
  """AIのパーソナリティ設定"""
  aiPersonality: AiPersonality

  """メッセージ内容"""
  content: String!

  """対局ID"""
  matchId: String!
}

"""チャットメッセージ送信結果"""
type SendChatMessageResult {
  """送信成功フラグ"""
  success: Boolean!
}

"""対局作成リクエスト"""
input StartMatchInput {
  """後手のプレイヤータイプ"""
  goteType: PlayerType!

  """対局ID（指定しない場合は自動生成）"""
  id: String

  """後手のプレイヤー名"""
  playerGote: String

  """先手のプレイヤー名"""
  playerSente: String

  """先手のプレイヤータイプ"""
  senteType: PlayerType!

  """初期局面（SFEN形式、指定しない場合は平手の初期局面）"""
  sfen: String
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """An array relationship"""
  chatMessages(
    """distinct select on columns"""
    distinctOn: [ChatMessagesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ChatMessagesOrderBy!]

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!

  """fetch data from the table: "chat_messages" using primary key columns"""
  chatMessagesByPk(id: String!): ChatMessages

  """
  fetch data from the table in a streaming manner: "chat_messages"
  """
  chatMessagesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ChatMessagesStreamCursorInput]!

    """filter the rows returned"""
    where: ChatMessagesBoolExp
  ): [ChatMessages!]!

  """
  fetch data from the table: "evaluations"
  """
  evaluations(
    """distinct select on columns"""
    distinctOn: [EvaluationsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EvaluationsOrderBy!]

    """filter the rows returned"""
    where: EvaluationsBoolExp
  ): [Evaluations!]!

  """fetch data from the table: "evaluations" using primary key columns"""
  evaluationsByPk(id: String!): Evaluations

  """
  fetch data from the table in a streaming manner: "evaluations"
  """
  evaluationsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EvaluationsStreamCursorInput]!

    """filter the rows returned"""
    where: EvaluationsBoolExp
  ): [Evaluations!]!

  """An array relationship"""
  matchStates(
    """distinct select on columns"""
    distinctOn: [MatchStatesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchStatesOrderBy!]

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!

  """fetch data from the table: "match_states" using primary key columns"""
  matchStatesByPk(index: Int!, matchId: String!): MatchStates

  """
  fetch data from the table in a streaming manner: "match_states"
  """
  matchStatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MatchStatesStreamCursorInput]!

    """filter the rows returned"""
    where: MatchStatesBoolExp
  ): [MatchStates!]!

  """
  fetch data from the table: "matches"
  """
  matches(
    """distinct select on columns"""
    distinctOn: [MatchesSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MatchesOrderBy!]

    """filter the rows returned"""
    where: MatchesBoolExp
  ): [Matches!]!

  """fetch data from the table: "matches" using primary key columns"""
  matchesByPk(id: String!): Matches

  """
  fetch data from the table in a streaming manner: "matches"
  """
  matchesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MatchesStreamCursorInput]!

    """filter the rows returned"""
    where: MatchesBoolExp
  ): [Matches!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input TimestampComparisonExp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _isNull: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

